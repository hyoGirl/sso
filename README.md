# sso
## 单点登陆以及注销

参考网站：https://www.cnblogs.com/ywlaker/p/6113927.html

- 浏览器第一次请求客户端1
```

客户端1 检测到没有登录，就跳转到sso服务器站点上

sso服务端检测到用户没有登录就跳转到登录页面

同时还携带了浏览器上输入的地址，作为登录通过后的跳转地址

```

- SSO服务端拦截校验
```

sso 服务器通过校验输入的账户/密码  登录成功后，生成一个token，

同时还把token 和用户信息绑定到一起。还在cookie中设置了一个登陆成功的标志。

写到第一个cookie中。这个第一个cookie是客户端与sso服务器的全局会话。

接着就是跳转到客户端1传递过来的地址上。同时token也作为参数传递过来了。
```
- 客户端1校验以及再次请求

```
客户端1检查，发现在session中没有登录成功的标志，(因为这时候访问的session还是浏览器第一次请求时的cookie，自动携带的原因，里面没有信息)，
所以还是没有登录，


但是发现在url后面还存在token参数，于是，客户端1接着再去校验sso 服务器去校验token

token校验成功后，把登录站点记录下来放置到set类似容器中。同时还会把这个登录用户和token绑定在一起，放在map中。

就在这个session中设置好登录成功的标志，生成第二个cookie。接着发送到浏览器上。  

当再输入其他地址请求客户端1的时候，由于会自动携带第二个cookie。通过获取里面的session id 就可以发现这个登录成功的标志，从而可以任意访问客户端1.

有了这个登录成功的标志，后续还需要判断这个token是不是保存在无效的set B中，如果存在，就说明被注销了，反过来就不是了。可以任意登录了。

这个第二个cookie是是浏览器与客户端1的局部会话。

```

- 浏览器第一次请求客户端2/3/4/5

```
当去请求客户端2的时候，

客户端2发现没有登录，就跳转到sso服务器站点上，当再次访问到sso服务站点的时候，会携带第一个cookie。(这个其实就相当于第一次访问了sso。sso生成了cookie，第二次就自动携带这个cookie)


sso服务端获取这个cookie里面的信息，知道已经登录成功了，此时就再次返回到客户端2上携带过来的地址。这样就完事了。

```

## 单点注销
- 效果

```
当一个客户进行注销的时候，其实就是让所有客户端的其他页面关于这个客户的session失效。

怎么体现这个效果尼？就是当其他系统再次跳转到下一个页面的时候，或者是在当前页面进行其他操作的时候，要登录了

```
- 实现

```
在登录中，

成功后，会把站点信息放置在set中，所以当进行退出操作的时候，

1：首先是销毁自己本地的session
2：就是遍历这个set集合，获取里面的客户端站点信息

然后重定向到SSO服务端去进行注销
```

- 具体逻辑
```
3：SSO服务端销毁的过程是：

sso销毁不是立刻销毁，或者说效果不是立刻展示，要用户在其他系统再次进行操作的时候显示出来，


我们可以设置一个set   B用来存放过期的token。


然后 sso的销毁其实就是把这个无效了的token放置到set中。


同时在拦截器中，增加判断


如果用户携带的session中存在了登录成功的标志，然后获取其中的token去校验，此时这个token已经存在了刚新建的set中


就是说明这个session要进行销毁了，所以注销自己的本次运行的session


如果不存在，就说明这个token信息没有被保存到新建的过期set中，就直接放行就ok了。
```

- 后续
```
1：怎么取消浏览器跳转的token，显示正常的地址/

可以把token设置到浏览器头部就可以了。
```



